/*******************************************************************************
*                                                                              *
* Numerics.templates                                                           *
*                                                                              *
* C++ code written by Walter Dehnen, 1994,                                     *
* Oxford University, Department of Physics, Theoretical Physics                *
* address: Box 43, SE-221 00 Lund, Sweden                                      *
* e-mail : dehnen@thphys.ox.ac.uk                                              *
*                                                                              *
*------------------------------------------------------------------------------*
*  In the following                                                            *
*                                                                              *
* C  denotes  any user defined class                                           *
* S  denotes  a scalar: a type for which the following operators are defined   *
*             =, +=, -=, *=, /=, +, -, *, /, <, >, <=, >=, !=, and ==          *
*             between S and which allows for explicit conversion from a float  *
* R  denotes  a scalar for which additionally to the operators a S allows all  *
*             the standard mathematical functions are defined.                 *
* T  denotes  a type for which the following operators are defined             *
*             =, +=, -=, +, -, !=, and ==  between T                           *
*             =, *=, /=, *, and /  between a T and a S or R                    *
*             (e.g. a Vector or a Matrix)                                      *
*                                                                              *
********************************************************************************
*                                                                              *
* the following NON-INLINE FUNCTION TEMPLATES are defined:                     *
*                                                                              *

* int hunt(S*xarr, const int n, S x, const int j);                             *
*    hunts the ordered table xarr for jlo such that xarr[jlo]<=x<xarr[jlo+1]   *
*    on input j provides a guess for the final value of jlo.                   *
*                                                                              *
* template<class S, class T>                                                   *
* T polint(S *xa, T *ya, const int n, S x)                                     *
*    polynom interpolation using n values: returns y(x) given x_i, y_i         *
*                                                                              *
* template<class S, class T>                                                   *
* T polev(S x, S*xarr, T*yarr, const int n, const int m=4)                     *
*    given the arrays xarr, yarr, polev returns y(x) using m of n values.      *
*                                                                              *
* template<class S, class T>                                                   *
* T polev_2d(S x1, S x2, S*x1arr, S *x2arr, T**yarr, const int n1,             *
*            const int n2, const int m1=4, const int m2=4)                     *
*    2D polynomial interpolation                                               *
*                                                                              *
* template<class S, class T>                                                   *
* T polev_3d(S x1, S x2, S x3, S*x1arr, S *x2arr, S *x3arr, T***yarr,          *
*            const int n1, const int n2, const int n3,                         *
*            const int m1=4, const int m2=4, const int m3=4)                   *
*    3D polynomial interpolation                                               *
*                                                                              *
* template<class S, class T>                                                   *
* void spline(S *x, T *y, const int n, const S yp1, const S ypn, T *y2,        *
*	      const int nat1=0, const int natn=0) 			       *
*    computes spline coefficients                                              *
*                                                                              *
* template<class S, class T>                                                   *
* T splout(S *x, T *y, const int n, const S yp1, const S ypn, const S xi,      *
*	      const int nat1=0, const int natn=0) 			       *
*    computes spline coefficients AND value of spline at xi, no coeffs. output *
*                                                                              *
* template<class S, class T>                                                   *
* T splev(S *x, T* y, T *y2, const int n, const S xi)                          *
*    given spline coeffs computes spline, tries old values for KLO, KHI        *
*                                                                              *
* template<class S, class T>                                                   *
* T splev(S *x, T* y, T *y2, const int n, const S xi, T& dy)                   *
*    given spline coeffs computes spline & first derivative		       *
*                                                                              *
* template<class S, class T>                                                   *
* T splev(S *x, T* y, T *y2, const int n, const S xi, T& dy, T& d2y)           *
*    given spline coeffs computes spline & first+second derivative	       *
*                                                                              *
* template<class C, class S>                                                   *
* S qbulir(C*, S(C::*)(S), const S, const S, const S)                          *
*    integrates a member function                                              *
*                                                                              *
********************************************************************************
*                                                                              *
* dependencies:                                                                *
* rtsafe()        abs()                                                        *
* hunt()           -                                                           *
* poline()         -                                                           *
* polev()         polint(), hunt()                                             *
* polev_2d()      polint(), hunt()                                             *
* polev_3d()      polint(), hunt()                                             *
* spline()         -                                                           *
* splout()         -                                                           *
* splev()         hunt()                                                       *
* qbulir()        abs()                                                        *
* HeapIndex()      -                                                           *
* HeapIndexAbs()  abs()                                                        *
*******************************************************************************/

#ifndef _Numerics_templates_def_
#define _Numerics_templates_def_ 1

#include <iostream>
#include "Inline.h"
#include "Vector.h"
#include "Matrix.h"

////////////////////////////////////////////////////////////////////////////////

#define polev2D  polev_2d
#define polev3D  polev_3d
#define spline2D spline_2d
#define spline3D spline_3d
#define splev2D  splev_2d
#define splev3D  splev_3d

////////////////////////////////////////////////////////////////////////////////

#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);


////////////////////////////////////////////////////////////////////////////////
template<class S>
int hunt(const S*xarr, const int n, const S x, const int j)
// hunts the ordered table xarr for jlo such that xarr[jlo]<=x<xarr[jlo+1]
// on input j provides a guess for the final value of jlo.
// for an ascendingly ordered array, we return
//  -1 for         x < x[0]
//   i for x[i] <= x < x[i+1]  if  0<=i<n
// n-1 for         x == x[n-1]
// n   for         x >  x[n-1]
{
    int jm,jlo=j,jhi,l=n-1;
    int ascnd=(xarr[l]>xarr[0]);

    if(!ascnd && xarr[l]==xarr[0] ) return -1;	// x_0 = x_l
    if( (ascnd && x<xarr[0]) || (!ascnd && x>xarr[0]) ) return -1;
    if( (ascnd && x>xarr[l]) || (!ascnd && x<xarr[l]) ) return  n;

    if(jlo<0 || jlo>l) {                   // input guess not useful,
        jlo = -1;                          //    go to bisection below
	jhi = n;
    } else {
        int inc = 1;
	if(x>=xarr[jlo] == ascnd) {        // hunt upward
	    if(jlo == l) return (x==xarr[l])? l : n;
	    jhi = jlo+1;
	    while(x>=xarr[jhi] == ascnd) { // not done hunting
		jlo =jhi;
		inc+=inc;                  // so double the increment
		jhi =jlo+inc;
		if(jhi>l) {                // off end of table
		    jhi=n;
		    break;
		}
	    }
        } else {                           // hunt downward
	    if(jlo == 0) return -1;
	    jhi = jlo;
	    jlo-= 1;
	    while(x<xarr[jlo] == ascnd) {  // not done hunting
		jhi = jlo;
		inc+= inc;                 // so double the increment
		jlo = jhi-inc;
		if(jlo < 0) {              // off end of table
		    jlo = 0;
		    break;
		}
	    }
        }
    }
    while (jhi-jlo != 1) {                 // bisection phase
	jm=(jhi+jlo) >> 1;
	if(x>=xarr[jm] == ascnd) jlo=jm;
	else jhi=jm;
    }
    return jlo;
}

////////////////////////////////////////////////////////////////////////////////
template<class S>
inline void find(int& klo, const int n, S const *x, const S xi)
{
    if(klo<0 || klo>=n-1 || x[klo]>xi || x[klo+1]<xi) {
	klo = int( (xi-x[0]) / (x[n-1]-x[0]) * (n-1) );
	klo = hunt(x,n,xi,klo);
        if(klo<0 || klo>=n){
	std::cerr << ' ' << xi << ' ' << x[0] << ' ' << x[n-1]; 	    
	Numerics_error("find: x out of range");
    	}
    }
}

////////////////////////////////////////////////////////////////////////////////
template<class S>
inline int find_for_polev(int& j, const int n, const int m, const S *x, const S xi)
{
    register int M=m;
    j = int( (xi-x[0]) / (x[n-1]-x[0]) * (n-1) );
    j = hunt(x,n,xi,j) - (m+1)/2 + 1;
    if(j>=0 && j<n && x[j]==xi)	 M = 1; 	// no interpolation required
    else if(j<0)		 j = 0;
    else if(j>n-M)		 j = n-M;
    return M;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T polint(const S *xa, const T *ya, const int n, const S x)
// polynom interpolation using n values
{
    register int i,m;
    register T   y, *P=new T[n];

    for(i=0;i<n;i++) P[i]=ya[i];
    for(m=1;m<n;m++)
	for(i=0;i<n-m;i++) {
	    if(xa[i]==xa[i+m]) Numerics_error("x's not distinct in polint");
	    P[i]= ( (x-xa[i+m])*P[i] + (xa[i]-x)*P[i+1] ) / (xa[i] - xa[i+m]);
	}
    y = P[0];    
    delete[] P;
    return y;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T polev(S x, S*xarr, T*yarr, const int n, const int m=4)
// given the arrays xarr, yarr, polev returns y(x) using m of n values.
{
    int j, M=find_for_polev(j,n,m,xarr,x);
    return polint(xarr+j, yarr+j, M, x);
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T polev_2d(const S xi[2], S* const xarr[2], T**yarr, const int n[2], const int m[2]=0)
// polynomial interpolation in 2 dimensions using m1xm2 of n1xn2 values
{
    int j[2], M[2];
    if(m) {
        M[0] = find_for_polev(j[0],n[0],m[0],xarr[0],xi[0]);
        M[1] = find_for_polev(j[1],n[1],m[1],xarr[1],xi[1]);
    } else {
        M[0] = find_for_polev(j[0],n[0],4,xarr[0],xi[0]);
        M[1] = find_for_polev(j[1],n[1],4,xarr[1],xi[1]);
    }

    register int l;
    T *y0 = new T[M[0]];
    for(l=0;l<M[0];l++)
	y0[l] = polint(xarr[1]+j[1], yarr[j[0]+l]+j[1], M[1], xi[1]);
    T y = polint(xarr[0]+j[0], y0, M[0], xi[0]);
    delete[] y0;
    return y;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T polev_3d(S    const xi[3],
	   S*   const xarr[3],
	   T***       yarr,
	   int  const n[3],
	   int  const m[3]=0)
// polynomial interpolation in 3 dimensions using m1xm2xm3 of n1xn2xn3 values
{
    int j[3], M[3];
    if(m) {
      M[0] = find_for_polev(j[0],n[0],m[0],xarr[0],xi[0]);
      M[1] = find_for_polev(j[1],n[1],m[1],xarr[1],xi[1]);
      M[2] = find_for_polev(j[2],n[2],m[2],xarr[2],xi[2]);
    } else {
      M[0] = find_for_polev(j[0],n[0],4,xarr[0],xi[0]);
      M[1] = find_for_polev(j[1],n[1],4,xarr[1],xi[1]);
      M[2] = find_for_polev(j[2],n[2],4,xarr[2],xi[2]);
    }
    register int k0,k1;
    T *y0 = new T[M[0]];
    T *y1 = new T[M[1]];
    for(k0=0; k0<M[0]; k0++) {
      for(k1=0; k1<M[1]; k1++)
	y1[k1] = polint(xarr[2]+j[2],yarr[j[0]+k0][j[1]+k1]+j[2],M[2],xi[2]);
      y0[k0] = polint(xarr[1]+j[1],y1,M[1],xi[1]);
    }
    T y = polint(xarr[0]+j[0],y0,M[0],xi[0]);
    delete[] y0;
    delete[] y1;
    return y;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void Spline(S*  const x,	// input:   table of points
	    T*  const y,	// input:   table of function values
	    int const n,	// input:   size of above tables
	    T*        y2,	// output:  table of y''
	    T*  const yp1=0,	// input:   y'(x[0])	nat if=0;
	    T*  const ypn=0)	// input:   y'(x[n-1])	nat if=0;
// pre-computes spline coefficients, modified NR routine:
// - x,y,y2 run from 0 to n-1 rather than from 1 to n;
// - option for natural spline explicit;
// - y can be of more general type than scalar, e.g., Vector, Matrix.
{ 
    const S  zero=0., half=0.5, one=1., two=2., three=3., six=6.;
    register int i;
    register S   qn,p,sig,dx,dx1,dx2;
             T   un,dy,dy1;
    T *u = new T[n-1];
    S *v = new S[n-1];
    dx   = x[1] - x[0];
    dy   = y[1] - y[0];
    if(yp1) {
	v[0] =-half;
	u[0] = three/dx * (dy/dx- *yp1);
    } else
	u[0] = v[0] = zero;
    for(i=1; i<n-1; i++) {
	dx1  = x[i+1]-x[i];
	dx2  = x[i+1]-x[i-1];
	dy1  = y[i+1]-y[i];
	sig  = dx/dx2;
	p    = sig*v[i-1]+two;
	v[i] = (sig-one)/p;
	u[i] = ( six*(dy1/dx1-dy/dx)/dx2 - sig*u[i-1] ) / p;
	dx   = dx1;
	dy   = dy1;
    }
    if(ypn) {
	qn = half;
	un = three/dx * (*ypn - dy/dx);
    } else
	un = qn = zero;
    y2[n-1]= (un-qn*u[n-2]) / (qn*v[n-2]+one);
    for(i=n-2; i>=0; i--)
        y2[i] = v[i]*y2[i+1] + u[i];
    delete[] u;
    delete[] v;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void SplinedY(S*  const x,	// input:   table of points
	      T*  const y,	// input:   table of function values
	      int const n,	// input:   size of above tables
	      T*        y1,	// output:  table of y'
	      T*  const yp1=0,	// input:   y'(x[0])	nat if=0;
	      T*  const ypn=0)	// input:   y'(x[n-1])	nat if=0;
// computes dy/dx of a cubic spline that passes through the given points
{ 
    const S  zero=0., half=0.5, one=1., two=2., three=3., six=6.;
    register int i;
    register S   qn,p,sig,dx,dx1,dx2;
    register T   un,dy,dy1;
    T *u = new T[n-1];
    T *y2= new T[n-1];
    S *v = new S[n-1];
    dx   = x[1] - x[0];
    dy   = y[1] - y[0];
    if(yp1) {
	v[0] =-half;
	u[0] = three/dx * (dy/dx- *yp1);
    } else
	u[0] = v[0] = zero;
    for(i=1; i<n-1; i++) {
	dx1  = x[i+1]-x[i];
	dx2  = x[i+1]-x[i-1];
	dy1  = y[i+1]-y[i];
	sig  = dx/dx2;
	p    = sig*v[i-1]+two;
	v[i] = (sig-one)/p;
	u[i] = ( six*(dy1/dx1-dy/dx)/dx2 - sig*u[i-1] ) / p;
	dx   = dx1;
	dy   = dy1;
    }
    if(ypn) {
	qn = half;
	un = three/dx * (*ypn - dy/dx);
    } else
	un = qn = zero;
    y2[n-1]= (un-qn*u[n-2]) / (qn*v[n-2]+one);
    for(i=n-2; i>=0; i--)
        y2[i] = v[i]*y2[i+1] + u[i];
    for(i=1; i<n; i++) {
        dx    = x[i]-x[i-1];
        dy    = y[i]-y[i-1];
	if(i==1) y1[0] = dy/dx - (y2[0] + half*y2[1])*dx/three;
	y1[i] = y1[i-1] + half*dx*(y2[i]+y2[i-1]);
    }
    delete[] v;
    delete[] y2;
    delete[] u;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void spline(S*  const x,	// input:   table of points
	    T*  const y,	// input:   table of function values
	    int const n,	// input:   size of above tables
	    T   const yp1,	// input:   y'(x[0])
	    T   const ypn,	// input:   y'(x[n-1])
	    T*        y2,	// output:  table of y''
	    int const nat1=0,	// input:   natural spline at x[0] ?
	    int const natn=0)	// input:   natural spline at x[n-1] ?
// pre-computes spline coefficients, modified NR routine:
// - x,y,y2 run from 0 to n-1 rather than from 1 to n;
// - option for natural spline explicit;
// - y can be of more general type than scalar, e.g., Vector, Matrix.
{ 
    const S  zero=0., half=0.5, one=1., two=2., three=3., six=6.;
    register int i;
    register S   qn,p,sig,dx,dx1,dx2;
             T   un,dy,dy1;
    T *u = new T[n-1];
    S *v = new S[n-1];
    dx   = x[1] - x[0];
    dy   = y[1] - y[0];
    if(nat1)
	u[0] = v[0] = zero;
    else {
	v[0] =-half;
	u[0] = three/dx * (dy/dx-yp1);
    }
    for(i=1; i<n-1; i++) {
	dx1  = x[i+1]-x[i];
	dx2  = x[i+1]-x[i-1];
	dy1  = y[i+1]-y[i];
	sig  = dx/dx2;
	p    = sig*v[i-1]+two;
	v[i] = (sig-one)/p;
	u[i] = ( six*(dy1/dx1-dy/dx)/dx2 - sig*u[i-1] ) / p;
	dx   = dx1;
	dy   = dy1;
    }
    if(natn)
	un = qn = zero;
    else {
	qn = half;
	un = three/dx * (ypn - dy/dx);
    }
    y2[n-1]= (un-qn*u[n-2]) / (qn*v[n-2]+one);
    for(i=n-2; i>=0; i--)
        y2[i] = v[i]*y2[i+1] + u[i];
    delete[] u;
    delete[] v;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splout(			// return:  y(xi)
	 S   const *x,		// input:   table of points
	 T   const *y,		// input:   table of function values
	 int const n,		// input:   size of above tables
	 T   const yp1,		// input:   y'(x[0])
	 T   const ypn,		// input:   y'(x[n-1])
	 S   const xi,		// input:   x-value where y is wanted
	 int const nat1=0,	// input:   natural spline at x[0] ?
	 int const natn=0)	// input:   natural spline at x[n-1] ?
// computes and interpolates spline, useful if only a single
// interpolation is required.
// modified from NR routines spline and splint:
// - x,y,y2 run from 0 to n-1 rather than from 1 to n;
// - option for natural spline explicit;
// - y can be of more general type than scalar, e.g., Vector, Matrix.
{
    const S  zero=0., half=0.5, one=1., two=2., three=3., six=6.;
    register int i, k, klo=0, khi=n-1;
    register S   a,b,h,qn,p,sig,dx,dx1,dx2;
    while(khi-klo > 1) {
	k=(khi+klo)/2;
	if(x[k]>xi) khi=k;
            else    klo=k;
    }
    if((h=x[khi]-x[klo])==zero) Numerics_error("splout: bad X input");
    if(x[klo]==xi) return y[klo];

    register T   Y,un,dy,dy1;
    T *y2= new T[n-1];
    T *u = new T[n-1];
    S *v = new S[n-1];
    dx   = x[1] - x[0];
    dy   = y[1] - y[0];
    if(nat1)
	u[0] = v[0] = zero;
    else {
	v[0] =-half;
	u[0] = three/dx * (dy/dx-yp1);
    }
    for(i=1; i<n-1; i++) {
	dx1  = x[i+1]-x[i];
	dx2  = x[i+1]-x[i-1];
	dy1  = y[i+1]-y[i];
	sig  = dx/dx2;
	p    = sig*v[i-1]+two;
	v[i] = (sig-one)/p;
	u[i] = ( six*(dy1/dx1-dy/dx)/dx2 - sig*u[i-1] ) / p;
	dx   = dx1;
	dy   = dy1;
    }
    if(natn)
	un = qn = zero;
    else {
	qn = half;
	un = three/dx * (ypn - dy/dx);
    }
    y2[n-1]= (un-qn*u[n-2]) / (qn*v[n-2]+one);
    for(i=n-2; i>=0; i--)
        y2[i] = v[i]*y2[i+1] + u[i];
    delete[] u;
    delete[] v;

    a = (x[khi]-xi) / h;
    b = (xi-x[klo]) / h;
    Y = a*y[klo] + b*y[khi] + ((a*a*a-a)*y2[klo]+(b*b*b-b)*y2[khi])*(h*h/six);
    delete[] y2;
    return Y;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splint(			// return:  y(xi)
	 S const *x,		// input:   table of points at x[lo]
	 T const *y,		// input:   table of function values at y[lo]
	 T const *y2,		// input:   table of y'' at y2[lo]
	 const S xi,		// input:   x-value where y is wanted
	 T* dy=0,		// output:  dy/dx(xi)     if dy  != 0
	 T* d2y=0)		// output:  d^2y/d^2x(xi) if d2y != 0
{
    const    S   zero=0., one=1., three=3., six=6.;
    register S   h,h6,A,B;
    if((h=x[1]-x[0])==zero) Numerics_error("splint bad X input");
    h6 = h / six;
    A  = (x[1]-xi) / h;
    B  = one - A;
    if(dy) {
        register S Aq=A*A, Bq=B*B;
        *dy = (y[1]-y[0])/h + h6*((three*Bq-one)*y2[1]-(three*Aq-one)*y2[0]);
        if(d2y) *d2y = A*y2[0] + B*y2[1];
        return A*y[0] +B*y[1] +((Aq-one)*A*y2[0]+(Bq-one)*B*y2[1])*(h*h6);
    }
    return A*y[0] +B*y[1] +(((A*A-one)*A)*y2[0]+((B*B-one)*B)*y2[1])*(h*h6);
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splinT(			// return:  y(xi)
	 const S xlo,		// input:   xlo < x
	 const S xhi,		// input:   x < xhi
	 const T ylo,		// input:   y(xlo)
	 const T yhi,		// input:   y(xhi)
	 const T y2lo,		// input:   y2(xlo)
	 const T y2hi,		// input:   y2(xhi)
	 const S xi,		// input:   xlo <= xi < xhi
	 T* dy=0,		// output:  dy/dx(xi)     if dy  != 0
	 T* d2y=0)		// output:  d^2y/d^2x(xi) if d2y != 0
{
    const    S   zero=0., one=1., three=3., six=6.;
    register S   h,h6,A,B;
    if((h=xhi-xlo)==zero) Numerics_error("splint bad X input");
    h6 = h / six;
    A  = (xhi-xi) / h;
    B  = one - A;
    if(dy) {
        register S Aq=A*A, Bq=B*B;
        *dy = (yhi-ylo)/h + h6*((three*Bq-one)*y2hi-(three*Aq-one)*y2lo);
        if(d2y) *d2y = A*y2lo + B*y2hi;
        return A*ylo +B*yhi +((Aq-one)*A*y2lo+(Bq-one)*B*y2hi)*(h*h6);
    }
    return A*ylo +B*yhi +(((A*A-one)*A)*y2lo+((B*B-one)*B)*y2hi)*(h*h6);
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void splinTarr(
	 S   const xl,		// input:   xl < x
	 S   const xh,		// input:   x < xh
	 S   const xi,		// input:   xlo <= xi < xhi
	 T*  const yl,	   	// input:   y_k(xl)
	 T*  const yh,		// input:   y_k(xh)
	 T*  const y2l,		// input:   y2_k(xl)
	 T*  const y2h,		// input:   y2_k(xh)
	 int const K,		// input:   k=0,...,K-1
	 T*  y,			// output:  y_k(xi)
	 T*  dy=0,		// output:  dy_k/dx(xi)     if dy  != 0
	 T*  d2y=0)		// output:  d^2y_k/d^2x(xi) if d2y != 0
{
// computes K splines simultaneously
    const    S   zero=0., one=1., three=3., six=6.;
    register T   *Y=y, *Yl=yl, *Yh=yh, *Y2l=y2l, *Y2h=y2h, *YK=y+K;
    register S   h,h6,hh,A,B,Aq,Bq,Ap,Bp;
    if((h=xh-xl)==zero) Numerics_error("splinTarr bad X input");
    h6=h/six;
    hh=h*h6;
    A =(xh-xi)/h;  Aq=A*A;  Ap=(Aq-one)*A*hh;
    B =one-A;      Bq=B*B;  Bp=(Bq-one)*B*hh;
    if(d2y) {
	register T *dY=dy, *d2Y=d2y;
	register S Au=h6*(three*Aq-one), Bu=h6*(three*Bq-one);
        for(; Y<YK; Y++,Yl++,Yh++,Y2l++,Y2h++,dY++,d2Y++) {
	    *Y   = A**Yl+B**Yh+Ap**Y2l+Bp**Y2h;
            *dY  = (*Yh-*Yl)/h + Bu**Y2h-Au**Y2l;
            *d2Y = A**Y2l + B**Y2h;
	}
    } else if(dy) {
	register T *dY=dy;
	register S Au=h6*(three*Aq-one), Bu=h6*(three*Bq-one);
        for(; Y<YK; Y++,Yl++,Yh++,Y2l++,Y2h++,dY++) {
	    *Y   = A**Yl+B**Yh+Ap**Y2l+Bp**Y2h;
            *dY  = (*Yh-*Yl)/h + Bu**Y2h-Au**Y2l;
	}
    } else {
        for(; Y<YK; Y++,Yl++,Yh++,Y2l++,Y2h++)
	    *Y   = A**Yl+B**Yh+Ap**Y2l+Bp**Y2h;
    }
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splev(			// return:  y(xi)
	 S const *x,		// input:   table of points
	 T const *y,		// input:   table of function values
	 T const *y2,		// input:   table of y''
	 const int n,		// input:   size of above tables
	 const S xi,		// input:   x-value where y is wanted
	 T* dy=0,		// output:  y'(xi)   if dy != 0
	 T* d2y=0)		// output:  y''(xi)  if d2y!= 0
// interpolates spline & gives first derivative;
// - x,y,y2 run from 0 to n-1 rather than from 1 to n;
// - y can be of more general type than scalar, e.g., Vector, Matrix.
// - takes old values of KLO and KHI to look whether they work again, else the
//   search for KLO, KHI is done using 'hunt' (NR) starting from linear 
//   interpolation.
{
    int lo=0;
    find(lo,n,x,xi);
    return splint(x+lo,y+lo,y2+lo,xi,dy,d2y);
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void spline_2d(
	S*   const x[2],    // input:   tables of points x[0][i], x[1][j]
	T**  const y,       // input:   table of function values y[i][j]
	int* const n,       // input:   sizes of above tables: n[0],n[1]
	T**        a[3],    // output:  tables of coeffs a[0],a[1],a[2]
	T*   const yp10=0,  // input:   dy/dx0(x0[0], x1[j])     nat if yp10 = 0
	T*   const ypn0=0,  // input:   dy/dx0(x0[n0-1], x1[j])  nat if ypn0 = 0
	T*   const yp11=0,  // input:   dy/dx0(x0[i], x1[0])     nat if yp11 = 0
	T*   const ypn1=0)  // input:   dy/dx0(x0[i], x1[n1-1])  nat if ypn1 = 0
{
    register int i,j;
    register T   yp1,ypn;
    T *t = new T[n[0]];
    T *t2= new T[n[0]];
// 1. for each x1 do 1D spline for y in x0
    for(j=0; j<n[1]; j++) {
	for(i=0; i<n[0]; i++)
	    t[i] = y[i][j];
        yp1 = (yp10)? yp10[j] : 0.;
        ypn = (ypn0)? ypn0[j] : 0.;
	spline(x[0],t,n[0],yp1,ypn,t2,int(yp10),int(ypn0));
	for(i=0; i<n[0]; i++)
	    a[1][i][j] = t2[i];
    }
// 2. do 1D splines for y and c0 in x1
    for(i=0; i<n[0]; i++) {
	spline(x[1],a[1][i],n[1],0.,0.,a[2][i],1,1);
        yp1 = (yp11)? yp11[i] : 0.;
        ypn = (ypn1)? ypn1[i] : 0.;
	spline(x[1],y[i],n[1],yp1,ypn,a[0][i],int(yp11),int(ypn1));
    }
    delete[] t;
    delete[] t2;
}

////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splev_2d(			// return:  y(x0i,x1i)
	S*   const x[2],	// input:   tables of points x[0][i], x[1][j]
	T**  const y,		// input:   table of function values y[i][j]
	T**  const a[3],	// input:   tables of coeffs a[0],a[1]
	int* const n,		// input:   sizes of above tables: n[0],n[1]
	S*   const xi,		// input:   (x0,x1)-value where y is wanted
	T*         dy=0,	// output:  gradient of y   if dy != 0
	T**        d2y=0)	// output:  d^2y/dxi/dxj    if d2y!= 0
{
    int l0=0, l1=0;
    register T yl,yh,y2l,y2h;
    find(l0,n[0],x[0],xi[0]);
    find(l1,n[1],x[1],xi[1]);
    if(d2y) {
	T dyl,dyh,dy2l,dy2h, d2yl,d2yh,d2y2l,d2y2h;
        yl = splint(x[1]+l1,y[l0]+l1,a[0][l0]+l1,xi[1],&dyl,&d2yl);
        yh = splint(x[1]+l1,y[l0+1]+l1,a[0][l0+1]+l1,xi[1],&dyh,&d2yh);
        y2l= splint(x[1]+l1,a[1][l0]+l1,a[2][l0]+l1,xi[1],&dy2l,&d2y2l);
        y2h= splint(x[1]+l1,a[1][l0+1]+l1,a[2][l0+1]+l1,xi[1],&dy2h,&d2y2h);
        dy[1]= splinT(x[0][l0],x[0][l0+1],dyl,dyh,dy2l,dy2h,xi[0],d2y[0]+1);
	d2y[1][0]= d2y[0][1];
        d2y[1][1]= splinT(x[0][l0],x[0][l0+1],d2yl,d2yh,d2y2l,d2y2h,xi[0]);
        return splinT(x[0][l0],x[0][l0+1],yl,yh,y2l,y2h,xi[0],dy,d2y[0]);
    } else if(dy) {
	T dyl,dyh,dy2l,dy2h;
        yl = splint(x[1]+l1,y[l0]+l1,a[0][l0]+l1,xi[1],&dyl);
        yh = splint(x[1]+l1,y[l0+1]+l1,a[0][l0+1]+l1,xi[1],&dyh);
        y2l= splint(x[1]+l1,a[1][l0]+l1,a[2][l0]+l1,xi[1],&dy2l);
        y2h= splint(x[1]+l1,a[1][l0+1]+l1,a[2][l0+1]+l1,xi[1],&dy2h);
        dy[1]= splinT(x[0][l0],x[0][l0+1],dyl,dyh,dy2l,dy2h,xi[0]);
        return splinT(x[0][l0],x[0][l0+1],yl,yh,y2l,y2h,xi[0],dy);
    }
    yl = splint(x[1]+l1,y[l0]+l1,a[0][l0]+l1,xi[1]);
    yh = splint(x[1]+l1,y[l0+1]+l1,a[0][l0+1]+l1,xi[1]);
    y2l= splint(x[1]+l1,a[1][l0]+l1,a[2][l0]+l1,xi[1]);
    y2h= splint(x[1]+l1,a[1][l0+1]+l1,a[2][l0+1]+l1,xi[1]);
    return splinT(x[0][l0],x[0][l0+1],yl,yh,y2l,y2h,xi[0]);
}

#ifdef Ralf
////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
void spline_3d(
	S*   const x[3],   // input:   tables of points x0, x1, x2
	T*** const y,      // input:   table of y
	int  const n[3],   // input:   sizes of tables: n[0],n[1],n[2]
	T*** a[7],         // output:  tables of coeffs a[i], i=0,...,6
	T**  yp10=0,  	   // input:   dy/dx0(x0[0], x1[j], x2[k])    nat if=0
	T**  ypn0=0,  	   // input:   dy/dx0(x0[n0-1], x1[j], x2[k]) nat if=0
	T**  yp11=0,       // input:   dy/dx1(x0[i], x1[0], x2[k])    nat if=0
	T**  ypn1=0,       // input:   dy/dx1(x0[i], x1[n1-1], x2[k]) nat if=0
	T**  yp12=0,       // input:   dy/dx2(x0[i], x1[j], x2[0])    nat if=0
	T**  ypn2=0)       // input:   dy/dx2(x0[i], x1[j], x2[n2-1]) nat if=0
{
// if the pointers yp?? = 0, a natural spline is used.
    register int i,j,k,nn=max(n[0],n[1]);
    T *t = new T[nn];
    T *t2= new T[nn];
// 1. for each x2 do 2D spline for y in x0-x1
    for(k=0; k<n[2]; k++) {
// 1.1 for each x1 do 1D spline for y in x0: a0
        for(j=0; j<n[1]; j++) {
	    for(i=0; i<n[0]; i++)
	        t[i] = y[i][j][k];
	        if(yp10) {
	            if(ypn0) Spline(x[0],t,n[0],t2,&(yp10[j][k]),&(ypn0[j][k]));
			else Spline(x[0],t,n[0],t2,&(yp10[j][k]));
		} else
		     Spline(x[0],t,n[0],t2);
	    for(i=0; i<n[0]; i++)
	        a[0][i][j][k] = t2[i];
        }
// 1.2 for each x0 do 1D splines for y and d^2y/d^2x0 in x1:  a1, a2
        for(i=0; i<n[0]; i++) {
	    for(j=0; j<n[1]; j++)
	        t[j] = y[i][j][k];
	        if(yp11) {
	            if(ypn1) Spline(x[1],t,n[1],t2,&(yp11[i][k]),&(ypn1[i][k]));
			else Spline(x[1],t,n[1],t2,&(yp11[i][k]));
		} else
		    Spline(x[1],t,n[1],t2);
	    for(j=0; j<n[1]; j++) {
	        a[1][i][j][k] = t2[j];
	        t[j] = a[0][i][j][k];
	    }
	    Spline(x[1],t,n[1],t2);
	    for(j=0; j<n[1]; j++)
	        a[2][i][j][k] = t2[j];
        }
    }
// 2. for each (x0,x1) do 1D splines of y,a0,a1,a2 in x2:  a3,a4,a5,a6
    for(i=0; i<n[0]; i++)
      for(j=0; j<n[1]; j++) {
	if(yp12) {
	  if(ypn2)
	    Spline(x[2],y[i][j],n[2],a[3][i][j],&(yp12[i][k]),&(ypn2[i][k]));
	  else
	    Spline(x[2],y[i][j],n[2],a[3][i][j],&(yp12[i][k]));
	} else
	  Spline(x[2],y[i][j],n[2],a[3][i][j]);
	Spline(x[2],a[0][i][j],n[2],a[4][i][j]);
	Spline(x[2],a[1][i][j],n[2],a[5][i][j]);
	Spline(x[2],a[2][i][j],n[2],a[6][i][j]);
        }
    delete[] t;
    delete[] t2;
}
////////////////////////////////////////////////////////////////////////////////
template<class S, class T>
T splev_3d(	          // return:   y(xi_0,xi_1,xi_2)
	S*   const x[3],  // input:    tables of points x[0],x[1],x[2]
	T*** const y,     // input:    table of y
	T*** const a[7],  // input:    table of coeffs
	int  const n[3],  // input:    sizes of tables
	S    const xi[3], // input:    (x0,x1,x2)-value where y is wanted
	T*   dy=0,        // output:   gradient of y   if dy != 0
	T**  d2y=0)       // output:   d^2y/dxi/dxj    if d2y!= 0
{
    int l0=0, l1=0, l2=0;
    find(l0,n[0],x[0],xi[0]);
    find(l1,n[1],x[1],xi[1]);
    find(l2,n[2],x[2],xi[2]);
    register int k0=l0+1, k1=l1+1, k2=l2+1;
    T  Al[16]={   y[l0][l1][l2],   y[k0][l1][l2],a[0][l0][l1][l2],a[0][k0][l1][l2],
                  y[l0][k1][l2],   y[k0][k1][l2],a[0][l0][k1][l2],a[0][k0][k1][l2],
               a[1][l0][l1][l2],a[1][k0][l1][l2],a[2][l0][l1][l2],a[2][k0][l1][l2],
               a[1][l0][k1][l2],a[1][k0][k1][l2],a[2][l0][k1][l2],a[2][k0][k1][l2]},
       Ah[16]={   y[l0][l1][k2],   y[k0][l1][k2],a[0][l0][l1][k2],a[0][k0][l1][k2],
                  y[l0][k1][k2],   y[k0][k1][k2],a[0][l0][k1][k2],a[0][k0][k1][k2],
               a[1][l0][l1][k2],a[1][k0][l1][k2],a[2][l0][l1][k2],a[2][k0][l1][k2],
               a[1][l0][k1][k2],a[1][k0][k1][k2],a[2][l0][k1][k2],a[2][k0][k1][k2]},
       Bl[16]={a[3][l0][l1][l2],a[3][k0][l1][l2],a[4][l0][l1][l2],a[4][k0][l1][l2],
               a[3][l0][k1][l2],a[3][k0][k1][l2],a[4][l0][k1][l2],a[4][k0][k1][l2],
               a[5][l0][l1][l2],a[5][k0][l1][l2],a[6][l0][l1][l2],a[6][k0][l1][l2],
               a[5][l0][k1][l2],a[5][k0][k1][l2],a[6][l0][k1][l2],a[6][k0][k1][l2]},
       Bh[16]={a[3][l0][l1][k2],a[3][k0][l1][k2],a[4][l0][l1][k2],a[4][k0][l1][k2],
               a[3][l0][k1][k2],a[3][k0][k1][k2],a[4][l0][k1][k2],a[4][k0][k1][k2],
               a[5][l0][l1][k2],a[5][k0][l1][k2],a[6][l0][l1][k2],a[6][k0][l1][k2],
               a[5][l0][k1][k2],a[5][k0][k1][k2],a[6][l0][k1][k2],a[6][k0][k1][k2]},
       A[16],B[4];
     if(d2y) {
       T dB[4],d2B[4],dA[16],d2A[16];
       splinTarr(x[2][l2],x[2][k2],xi[2],Al,Ah,Bl,Bh,16,A,dA,d2A);
       splinTarr(x[1][l1],x[1][k1],xi[1],d2A,d2A+4,d2A+8,d2A+12,4,B);
       d2y[2][2] =splinT(x[0][l0],x[0][k0],B[0],B[1],B[2],B[3],xi[0]);
       splinTarr(x[1][l1],x[1][k1],xi[1],dA,dA+4,dA+8,dA+12,4,B,dB);
       d2y[1][2] =splinT(x[0][l0],x[0][k0],dB[0],dB[1],dB[2],dB[3],xi[0]);
       d2y[2][1] =d2y[1][2];
       dy[2]     =splinT(x[0][l0],x[0][k0],B[0],B[1],B[2],B[3],xi[0],d2y[0]+2);
       d2y[2][0] =d2y[0][2];
       splinTarr(x[1][l1],x[1][k1],xi[1],A,A+4,A+8,A+12,4,B,dB,d2B);
       dy [1]    =splinT(x[0][l0],x[0][k0],dB[0],dB[1],dB[2],dB[3],xi[0],d2y[0]+1);
       d2y[1][0] =d2y[0][1];
       d2y[1][1] =splinT(x[0][l0],x[0][k0],d2B[0],d2B[1],d2B[2],d2B[3],xi[0]);
       return splinT(x[0][l0],x[0][k0],B[0],B[1],B[2],B[3],xi[0],dy,d2y[0]);
     } else if(dy) {
       T dB[4],dA[16];
       splinTarr(x[2][l2],x[2][k2],xi[2],Al,Ah,Bl,Bh,16,A,dA);
       splinTarr(x[1][l1],x[1][k1],xi[1],dA,dA+4,dA+8,dA+12,4,dB);
       dy[2] =splinT(x[0][l0],x[0][k0],dB[0],dB[1],dB[2],dB[3],xi[0]);
       splinTarr(x[1][l1],x[1][k1],xi[1],A,A+4,A+8,A+12,4,B,dB);
       dy[1] =splinT(x[0][l0],x[0][k0],dB[0],dB[1],dB[2],dB[3],xi[0]);
       return splinT(x[0][l0],x[0][k0],B[0],B[1],B[2],B[3],xi[0],dy);
     }
     splinTarr(x[2][l2],x[2][k2],xi[2],Al,Ah,Bl,Bh,16,A);	// splines in x2
     splinTarr(x[1][l1],x[1][k1],xi[1],A,A+4,A+8,A+12,4,B);	// splines in x1
     return splinT(x[0][l0],x[0][k0],B[0],B[1],B[2],B[3],xi[0]);// spline  in x0
}
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
/*
template<class C, class S>
S qbulir(C* o, S(C::*func)(S), const S a, const S b, const S eps_, S& err)
//------------------------------------------------------------------------------
// Quadrature program using the Bulirsch sequence and rational extrapolation.
// The algorithm is puplished in Bulirsch & Stoer, Num. Math. 9, 271-278 (1967),
// where a routine in ALGOL is given. This routine is a straightforward
// translation into C++.
// CAUTION: 
// Do not use this routine for integrating low order polynomials (up to fourth
// order) or periodic functions with period equal to the interval of integration
// or linear combinations of both.
// INPUT:  o      object of class C
//	func   pointer to member of object o: function to be integrated.
//      a,b    lower and upper boundaries of the integration interval;
//      eps    desired relativ accuracy;
// OUTPUT: return approximated value for the integral;
//      err    actual relative error of the return value.
//------------------------------------------------------------------------------
{
    register S ba=b-a;
    if(ba==0.) return 0.;

    register int    i,n=2,nn=3,mx=25,m,mr, bo,bu=0,odd=1;
    register S      c,d[7],d1,ddt,den,dt[7],e,eps,eta=S(1.e-7),
                    gr,hm,nt,sm,t,t1,t2,t2a,ta,tab,tb,v,w;

    while(eta+1. != 1.) eta *=S(0.5);
    eta  *=S(2.);                    // eta = actual computing accuracy

    eps   = max(eps_,eta);
    sm    = 0.;
    gr    = 0.;
    t1    = 0.;
    t2    = S(0.5)*((o->*func)(a)+(o->*func)(b));
    t2a   = t2;
    tb    = abs(t2a);
    c     = t2*ba;
    dt[0] = c;

    for(m=1;m<=mx;m++)             // iterate over the refinements
    {
	bo = (m>=7);
	hm = ba/n;
	if(odd) {
	    for(i=1;i<=n;i+=2)
	    {
		w  = (o->*func)(a+i*hm);
		t2+= w;
		tb+= abs(w);
	    }
	    nt   = t2;
	    tab  = tb * abs(hm);
	    d[1] = S(16./9.);
	    d[3] = S(64./9.);
	    d[5] = S(256./9.);
	} else {
	    for(i=1;i<=n;i+=6)
	    {
		w  = i*hm;
		t1+= (o->*func)(a+w) + (o->*func)(b-w);
	    }
	    nt   = t1+t2a;
	    t2a  = t2;
	    d[1] = S(2.25);
	    d[3] = S(9.);
	    d[5] = S(36.);
	}
	ddt   = dt[0];
	t     = nt*hm;
	dt[0] = t;
	nt    = dt[0];
	if(bo) {
	    mr   = 6;
	    d[6] = S(64.);
	    w    = S(144.);
	} else {
	    mr   = m;
	    d[m] = n*n;
	    w    = d[m];
	}
	for(i=1;i<=mr;i++)
	{
	    d1  = d[i]*ddt;
	    den = d1-nt;
	    e   = nt-ddt;
	    if(den != S(0.)) {
		e /= den;
		v  = nt*e;
		nt = d1*e;
		t += v;
	    } else {
		nt = S(0.);
		v  = S(0.);
	    }
	    ddt   = dt[i];
	    dt[i] = v;
	}
	ta = c;
	c  = t;
	if(!bo) t -= v;
	v   = t-ta;
	t  += v;
	err = abs(v);
	if(ta<t) {
	    d1 = ta;
	    ta = t;
	    t  = d1;
        }
	bo = bo || (ta<gr && t>sm);
	if(bu && bo && err < eps*tab*w) break;
	gr   = ta;
	sm   = t;
	odd  = !odd;
	i    = n;
	n    = nn;
	nn   = i+i;
	bu   = bo;
	d[2] = S(4.);
        d[4] = S(16.);
    }
    v = tab*eta;
    if(err<v) err = v;
    if(m==mx) cerr << " qbulir exceeding maximum of iterations\n";
    return c;
}
*/
////////////////////////////////////////////////////////////////////////////////
template<class C, class S>
S qbulir(const C* const o, S(C::*func)(S) const, const S a, const S b, const S eps_)
// as qbulir() above, but without return of an error estimate.
{
    register S ba=b-a;
    if(ba==0.) return 0.;

    register int    i,n=2,nn=3,mx=25,m,mr, bo,bu=0,odd=1;
	     S      d[7],dt[7];
    register S      c,d1,ddt,den,e,eps,err,eta=S(1.e-7),
                    gr,hm,nt,sm,t,t1,t2,t2a,ta,tab=0.,tb,v=0.,w;

    while(eta+1. != 1.) eta *=S(0.5);
    eta  *=S(2.);                    // eta = actual computing accuracy

    eps   = max(eps_,eta);
    sm    = 0.;
    gr    = 0.;
    t1    = 0.;
    t2    = S(0.5)*((o->*func)(a)+(o->*func)(b));
    t2a   = t2;
    tb    = abs(t2a);
    c     = t2*ba;
    dt[0] = c;

    for(m=1;m<=mx;m++)             // iterate over the refinements
    {
	bo = (m>=7);
	hm = ba/n;
	if(odd) {
	    for(i=1;i<=n;i+=2)
	    {
		w  = (o->*func)(a+i*hm);
		t2+= w;
		tb+= abs(w);
	    }
	    nt   = t2;
	    tab  = tb * abs(hm);
	    d[1] = S(16./9.);
	    d[3] = S(64./9.);
	    d[5] = S(256./9.);
	} else {
	    for(i=1;i<=n;i+=6)
	    {
		w  = i*hm;
		t1+= (o->*func)(a+w) + (o->*func)(b-w);
	    }
	    nt   = t1+t2a;
	    t2a  = t2;
	    d[1] = S(2.25);
	    d[3] = S(9.);
	    d[5] = S(36.);
	}
	ddt   = dt[0];
	t     = nt*hm;
	dt[0] = t;
	nt    = dt[0];
	if(bo) {
	    mr   = 6;
	    d[6] = S(64.);
	    w    = S(144.);
	} else {
	    mr   = m;
	    d[m] = n*n;
	    w    = d[m];
	}
	for(i=1;i<=mr;i++)
	{
	    d1  = d[i]*ddt;
	    den = d1-nt;
	    e   = nt-ddt;
	    if(den != S(0.)) {
		e /= den;
		v  = nt*e;
		nt = d1*e;
		t += v;
	    } else {
		nt = S(0.);
		v  = S(0.);
	    }
	    ddt   = dt[i];
	    dt[i] = v;
	}
	ta = c;
	c  = t;
	if(!bo) t -= v;
	v   = t-ta;
	t  += v;
	err = abs(v);
	if(ta<t) {
	    d1 = ta;
	    ta = t;
	    t  = d1;
        }
	bo = bo || (ta<gr && t>sm);
	if(bu && bo && err < eps*tab*w) break;
	gr   = ta;
	sm   = t;
	odd  = !odd;
	i    = n;
	n    = nn;
	nn   = i+i;
	bu   = bo;
	d[2] = S(4.);
        d[4] = S(16.);
    }
    v = tab*eta;
    if(m==mx) cerr << " qbulir exceeding maximum of iterations\n";
    return c;
}



////////////////////////////////////////////////////////////////////////////////
template<class S, int N>
void LegendrePeven(Vector<S,N>& p, const double x)
// based on a routine from J.J. Binney
// evaluates even Legendre Polys up to l=2*(N-1) at x
{
    register int    n,l,l2;
    register double x2=x*x;
    p[0] = 1.;
    p[1] = 1.5*x2-0.5;
    for(n=2; n<N; n++) {
	l    = 2*(n-1);
	l2   = 2*l;
	p[n] = - p[n-2] * l*(l-1)/double((l2+1)*(l2-1))
	       + p[n-1] * (x2 - (l2*l+l2-1)/double((l2-1)*(l2+3)) );
        p[n]*= (l2+1)*(l2+3) / double((l+1)*(l+2));
    }
}
template<class S, int N>
void dLegendrePeven(Vector<S,N>& p, Vector<S,N>& d, const double x)
// based on a routine from J.J. Binney
// evaluates even Legendre Polys and its derivs up to l=2*(N-1) at x
{
    register int    n,l,l2;
    register double x2=x*x;
    p[0] = 1.;
    d[0] = 0.;
    p[1] = 1.5*x2-0.5;
    d[1] = 1.5;
    for(n=2; n<N; n++) {
	l    = 2*(n-1);
	l2   = 2*l;
	p[n] = - p[n-2] * l*(l-1)/double((l2+1)*(l2-1))
	       + p[n-1] * (x2 - (l2*l+l2-1)/double((l2-1)*(l2+3)) );
        p[n]*= (l2+1)*(l2+3) / double((l+1)*(l+2));
        d[n] = - d[n-2] * l*(l-1)/double((l2+1)*(l2-1))
               + d[n-1] * (x2 - (l2*l+l2-1)/double((l2-1)*(l2+3)) )
	       + p[n-1];
        d[n]*= (l2+1)*(l2+3) / double((l+1)*(l+2));
    }
    x2 = 2*x;
    for(n=0; n<N; n++)
	d[n] *= x2;
}

#endif
